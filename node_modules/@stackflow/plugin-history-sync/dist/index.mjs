var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/historySyncPlugin.tsx
import { id, makeEvent } from "@stackflow/core";
import { createBrowserHistory, createMemoryHistory } from "history";

// src/historyState.ts
var STATE_TAG = `${"@stackflow/plugin-history-sync"}@${"1.3.2"}`;
function serializeStep(step) {
  return __spreadProps(__spreadValues({}, step), {
    enteredBy: "activityContext" in step.enteredBy ? __spreadProps(__spreadValues({}, step.enteredBy), {
      activityContext: void 0
    }) : __spreadValues({}, step.enteredBy)
  });
}
function serializeActivity(activity) {
  return __spreadProps(__spreadValues({}, activity), {
    context: void 0,
    enteredBy: __spreadProps(__spreadValues({}, activity.enteredBy), {
      activityContext: void 0
    }),
    steps: activity.steps.map(serializeStep)
  });
}
function serializeState(state) {
  return {
    _TAG: STATE_TAG,
    activity: serializeActivity(state.activity),
    step: state.step ? serializeStep(state.step) : void 0
  };
}
function safeParseState(state) {
  const _state = state;
  if (typeof _state === "object" && _state !== null && "_TAG" in _state && typeof _state._TAG === "string" && _state._TAG === STATE_TAG) {
    return state;
  }
  return null;
}
function getCurrentState({ history }) {
  return history.location.state;
}
function pushState({
  history,
  pathname,
  state,
  useHash
}) {
  const nextPathname = useHash ? `${history.location.pathname}#${pathname}` : pathname;
  history.push(nextPathname, serializeState(state));
}
function replaceState({
  history,
  pathname,
  state,
  useHash
}) {
  const nextPathname = useHash ? `${history.location.pathname}#${pathname}` : pathname;
  history.replace(nextPathname, serializeState(state));
}

// src/last.ts
function last(arr) {
  return arr.length === 0 ? void 0 : arr[arr.length - 1];
}

// src/makeTemplate.ts
import UrlPattern from "url-pattern";
function pathToUrl(path) {
  return new URL(path, "file://");
}
function urlSearchParamsToMap(urlSearchParams) {
  const map = {};
  urlSearchParams.forEach((value, key) => {
    map[key] = value;
  });
  return map;
}
function appendTrailingSlashInPathname(pathname) {
  if (pathname.endsWith("/")) {
    return pathname;
  }
  return `${pathname}/`;
}
function prependQuestionMarkInSearchParams(searchParams) {
  const searchParamsStr = searchParams.toString();
  if (searchParamsStr.length > 0) {
    return `?${searchParams}`;
  }
  return searchParams;
}
function makeTemplate(templateStr, urlPatternOptions) {
  const pattern = new UrlPattern(`${templateStr}(/)`, urlPatternOptions);
  return {
    fill(params) {
      const pathname = pattern.stringify(params);
      const pathParams = pattern.match(pathname);
      const searchParamsMap = __spreadValues({}, params);
      Object.keys(pathParams).forEach((key) => {
        delete searchParamsMap[key];
      });
      const searchParams = new URLSearchParams(
        Object.entries(searchParamsMap).reduce(
          (acc, [key, value]) => __spreadValues(__spreadValues({}, acc), value ? {
            [key]: value
          } : null),
          {}
        )
      );
      return appendTrailingSlashInPathname(pathname) + prependQuestionMarkInSearchParams(searchParams);
    },
    parse(path) {
      const url = pathToUrl(path);
      const pathParams = pattern.match(url.pathname);
      const searchParams = urlSearchParamsToMap(url.searchParams);
      if (!pathParams) {
        return null;
      }
      return __spreadValues(__spreadValues({}, searchParams), pathParams);
    }
  };
}

// src/normalizeRoute.ts
function normalizeRoute(route) {
  return typeof route === "string" ? [route] : route;
}

// src/queue.ts
var makeQueue = (history) => {
  let pending = false;
  const queue = (cb) => {
    const start = () => {
      pending = true;
      const clean = history.listen(() => {
        clean();
        pending = false;
      });
      cb();
    };
    if (pending) {
      const clean = history.listen(() => {
        clean();
        start();
      });
    } else {
      start();
    }
  };
  return queue;
};

// src/RoutesContext.tsx
import { createContext, useContext } from "react";
import { jsx } from "react/jsx-runtime";
var RoutesContext = createContext({});
var RoutesProvider = (props) => /* @__PURE__ */ jsx(RoutesContext.Provider, { value: props.routes, children: props.children });
RoutesProvider.displayName = "RoutesProvider";
function useRoutes() {
  return useContext(RoutesContext);
}

// src/historySyncPlugin.tsx
import { jsx as jsx2 } from "react/jsx-runtime";
var SECOND = 1e3;
var MINUTE = 60 * SECOND;
function historySyncPlugin(options) {
  var _a;
  const history = (_a = options.history) != null ? _a : typeof window === "undefined" ? createMemoryHistory({}) : createBrowserHistory({
    window
  });
  const { location } = history;
  return () => {
    let pushFlag = 0;
    let popFlag = 0;
    const queue = makeQueue(history);
    return {
      key: "plugin-history-sync",
      wrapStack({ stack }) {
        return /* @__PURE__ */ jsx2(RoutesProvider, { routes: options.routes, children: stack.render() });
      },
      overrideInitialEvents({ initialContext }) {
        var _a2, _b;
        const initialHistoryState = safeParseState(
          getCurrentState({ history })
        );
        if (initialHistoryState) {
          return [
            __spreadProps(__spreadValues({}, initialHistoryState.activity.enteredBy), {
              name: "Pushed"
            }),
            ...((_a2 = initialHistoryState.step) == null ? void 0 : _a2.enteredBy.name) === "StepPushed" || ((_b = initialHistoryState.step) == null ? void 0 : _b.enteredBy.name) === "StepReplaced" ? [
              __spreadProps(__spreadValues({}, initialHistoryState.step.enteredBy), {
                name: "StepPushed"
              })
            ] : []
          ];
        }
        function resolvePath() {
          var _a3, _b2;
          if (((_a3 = initialContext == null ? void 0 : initialContext.req) == null ? void 0 : _a3.path) && typeof initialContext.req.path === "string") {
            return initialContext.req.path;
          }
          if (options.useHash) {
            return (_b2 = location.hash.split("#")[1]) != null ? _b2 : "/";
          }
          return location.pathname + location.search;
        }
        const path = resolvePath();
        const activityNames = Object.keys(options.routes);
        if (path) {
          for (let i = 0; i < activityNames.length; i += 1) {
            const activityName = activityNames[i];
            const routes = normalizeRoute(options.routes[activityName]);
            for (let j = 0; j < routes.length; j += 1) {
              const route = routes[j];
              const template = makeTemplate(route, options.urlPatternOptions);
              const activityParams = template.parse(path);
              const matched = !!activityParams;
              if (matched) {
                const activityId = id();
                return [
                  makeEvent("Pushed", {
                    activityId,
                    activityName,
                    activityParams: __spreadValues({}, activityParams),
                    eventDate: new Date().getTime() - MINUTE,
                    activityContext: {
                      path
                    }
                  })
                ];
              }
            }
          }
        }
        const fallbackActivityId = id();
        const fallbackActivityName = options.fallbackActivity({
          initialContext
        });
        const fallbackActivityRoutes = normalizeRoute(
          options.routes[fallbackActivityName]
        );
        const fallbackActivityPath = fallbackActivityRoutes[0];
        return [
          makeEvent("Pushed", {
            activityId: fallbackActivityId,
            activityName: fallbackActivityName,
            activityParams: {},
            eventDate: new Date().getTime() - MINUTE,
            activityContext: {
              path: fallbackActivityPath
            }
          })
        ];
      },
      onInit({ actions: { getStack, dispatchEvent, push, stepPush } }) {
        const rootActivity = getStack().activities[0];
        const template = makeTemplate(
          normalizeRoute(options.routes[rootActivity.name])[0],
          options.urlPatternOptions
        );
        const lastStep = last(rootActivity.steps);
        queue(
          () => replaceState({
            history,
            pathname: template.fill(rootActivity.params),
            state: {
              activity: rootActivity,
              step: lastStep
            },
            useHash: options.useHash
          })
        );
        const onPopState = (e) => {
          if (popFlag) {
            popFlag -= 1;
            return;
          }
          const historyState = safeParseState(e.location.state);
          if (!historyState) {
            return;
          }
          const targetActivity = historyState.activity;
          const targetActivityId = historyState.activity.id;
          const targetStep = historyState.step;
          const { activities } = getStack();
          const currentActivity = activities.find(
            (activity) => activity.isActive
          );
          if (!currentActivity) {
            return;
          }
          const currentStep = last(currentActivity.steps);
          const nextActivity = activities.find(
            (activity) => activity.id === targetActivityId
          );
          const nextStep = currentActivity.steps.find(
            (step) => step.id === (targetStep == null ? void 0 : targetStep.id)
          );
          const isBackward = () => currentActivity.id > targetActivityId;
          const isForward = () => currentActivity.id < targetActivityId;
          const isStep = () => currentActivity.id === targetActivityId;
          const isStepBackward = () => {
            if (!isStep()) {
              return false;
            }
            if (!targetStep) {
              return true;
            }
            if (currentStep && currentStep.id > targetStep.id) {
              return true;
            }
            return false;
          };
          const isStepForward = () => {
            if (!isStep()) {
              return false;
            }
            if (!currentStep) {
              return true;
            }
            if (targetStep && currentStep.id < targetStep.id) {
              return true;
            }
            return false;
          };
          if (isBackward()) {
            dispatchEvent("Popped", {});
            if (!nextActivity) {
              pushFlag += 1;
              push(__spreadValues({}, targetActivity.enteredBy));
              if ((targetStep == null ? void 0 : targetStep.enteredBy.name) === "StepPushed" || (targetStep == null ? void 0 : targetStep.enteredBy.name) === "StepReplaced") {
                pushFlag += 1;
                stepPush(__spreadValues({}, targetStep.enteredBy));
              }
            }
          }
          if (isStepBackward()) {
            if (!nextStep && targetStep && ((targetStep == null ? void 0 : targetStep.enteredBy.name) === "StepPushed" || (targetStep == null ? void 0 : targetStep.enteredBy.name) === "StepReplaced")) {
              pushFlag += 1;
              stepPush(__spreadValues({}, targetStep.enteredBy));
            }
            dispatchEvent("StepPopped", {});
          }
          if (isForward()) {
            pushFlag += 1;
            push({
              activityId: targetActivity.id,
              activityName: targetActivity.name,
              activityParams: targetActivity.params
            });
          }
          if (isStepForward()) {
            if (!targetStep) {
              return;
            }
            pushFlag += 1;
            stepPush({
              stepId: targetStep.id,
              stepParams: targetStep.params
            });
          }
        };
        history.listen(onPopState);
      },
      onPushed({ effect: { activity } }) {
        if (pushFlag) {
          pushFlag -= 1;
          return;
        }
        const template = makeTemplate(
          normalizeRoute(options.routes[activity.name])[0],
          options.urlPatternOptions
        );
        queue(
          () => pushState({
            history,
            pathname: template.fill(activity.params),
            state: {
              activity
            },
            useHash: options.useHash
          })
        );
      },
      onStepPushed({ effect: { activity, step } }) {
        if (pushFlag) {
          pushFlag -= 1;
          return;
        }
        const template = makeTemplate(
          normalizeRoute(options.routes[activity.name])[0],
          options.urlPatternOptions
        );
        queue(
          () => pushState({
            history,
            pathname: template.fill(activity.params),
            state: {
              activity,
              step
            },
            useHash: options.useHash
          })
        );
      },
      onReplaced({ effect: { activity } }) {
        if (!activity.isActive) {
          return;
        }
        const template = makeTemplate(
          normalizeRoute(options.routes[activity.name])[0],
          options.urlPatternOptions
        );
        queue(
          () => replaceState({
            history,
            pathname: template.fill(activity.params),
            state: {
              activity
            },
            useHash: options.useHash
          })
        );
      },
      onStepReplaced({ effect: { activity, step } }) {
        if (!activity.isActive) {
          return;
        }
        const template = makeTemplate(
          normalizeRoute(options.routes[activity.name])[0],
          options.urlPatternOptions
        );
        queue(
          () => replaceState({
            history,
            pathname: template.fill(activity.params),
            state: {
              activity,
              step
            },
            useHash: options.useHash
          })
        );
      },
      onBeforePush({ actionParams, actions: { overrideActionParams } }) {
        const template = makeTemplate(
          normalizeRoute(options.routes[actionParams.activityName])[0],
          options.urlPatternOptions
        );
        const path = template.fill(actionParams.activityParams);
        overrideActionParams(__spreadProps(__spreadValues({}, actionParams), {
          activityContext: __spreadProps(__spreadValues({}, actionParams.activityContext), {
            path
          })
        }));
      },
      onBeforeReplace({ actionParams, actions: { overrideActionParams } }) {
        const template = makeTemplate(
          normalizeRoute(options.routes[actionParams.activityName])[0],
          options.urlPatternOptions
        );
        const path = template.fill(actionParams.activityParams);
        overrideActionParams(__spreadProps(__spreadValues({}, actionParams), {
          activityContext: __spreadProps(__spreadValues({}, actionParams.activityContext), {
            path
          })
        }));
      },
      onBeforeStepPop({ actions: { getStack } }) {
        var _a2;
        const { activities } = getStack();
        const currentActivity = activities.find(
          (activity) => activity.isActive
        );
        if (((_a2 = currentActivity == null ? void 0 : currentActivity.steps.length) != null ? _a2 : 0) > 1) {
          popFlag += 1;
          queue(history.back);
        }
      },
      onBeforePop({ actions: { getStack } }) {
        var _a2;
        const { activities } = getStack();
        const currentActivity = activities.find(
          (activity) => activity.isActive
        );
        const popCount = (_a2 = currentActivity == null ? void 0 : currentActivity.steps.length) != null ? _a2 : 0;
        popFlag += popCount;
        do {
          for (let i = 0; i < popCount; i += 1) {
            queue(history.back);
          }
        } while (!safeParseState(getCurrentState({ history })));
      }
    };
  };
}
export {
  historySyncPlugin,
  makeTemplate,
  normalizeRoute,
  useRoutes
};
//# sourceMappingURL=index.mjs.map
