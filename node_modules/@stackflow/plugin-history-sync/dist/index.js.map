{
  "version": 3,
  "sources": ["../src/index.ts", "../src/historySyncPlugin.tsx", "../src/historyState.ts", "../src/last.ts", "../src/makeTemplate.ts", "../src/normalizeRoute.ts", "../src/queue.ts", "../src/RoutesContext.tsx"],
  "sourcesContent": ["export * from \"./historySyncPlugin\";\nexport { makeTemplate, UrlPatternOptions } from \"./makeTemplate\";\nexport { normalizeRoute } from \"./normalizeRoute\";\nexport { useRoutes } from \"./RoutesContext\";\n", "import { id, makeEvent } from \"@stackflow/core\";\nimport type { StackflowReactPlugin } from \"@stackflow/react\";\nimport type { History, Listener } from \"history\";\nimport { createBrowserHistory, createMemoryHistory } from \"history\";\n\nimport {\n  getCurrentState,\n  pushState,\n  replaceState,\n  safeParseState,\n} from \"./historyState\";\nimport { last } from \"./last\";\nimport type { UrlPatternOptions } from \"./makeTemplate\";\nimport { makeTemplate } from \"./makeTemplate\";\nimport { normalizeRoute } from \"./normalizeRoute\";\nimport { makeQueue } from \"./queue\";\nimport { RoutesProvider } from \"./RoutesContext\";\n\nconst SECOND = 1000;\nconst MINUTE = 60 * SECOND;\n\ntype HistorySyncPluginOptions<K extends string> = {\n  routes: {\n    [key in K]: string | string[];\n  };\n  fallbackActivity: (args: { initialContext: any }) => K;\n  useHash?: boolean;\n  history?: History;\n  urlPatternOptions?: UrlPatternOptions;\n};\nexport function historySyncPlugin<\n  T extends { [activityName: string]: unknown },\n>(\n  options: HistorySyncPluginOptions<Extract<keyof T, string>>,\n): StackflowReactPlugin<T> {\n  type K = Extract<keyof T, string>;\n\n  const history =\n    options.history ??\n    (typeof window === \"undefined\"\n      ? createMemoryHistory({})\n      : createBrowserHistory({\n          window,\n        }));\n\n  const { location } = history;\n\n  return () => {\n    let pushFlag = 0;\n    let popFlag = 0;\n\n    const queue = makeQueue(history);\n\n    return {\n      key: \"plugin-history-sync\",\n      wrapStack({ stack }) {\n        return (\n          <RoutesProvider routes={options.routes}>\n            {stack.render()}\n          </RoutesProvider>\n        );\n      },\n      overrideInitialEvents({ initialContext }) {\n        const initialHistoryState = safeParseState(\n          getCurrentState({ history }),\n        );\n\n        if (initialHistoryState) {\n          return [\n            {\n              ...initialHistoryState.activity.enteredBy,\n              name: \"Pushed\",\n            },\n            ...(initialHistoryState.step?.enteredBy.name === \"StepPushed\" ||\n            initialHistoryState.step?.enteredBy.name === \"StepReplaced\"\n              ? [\n                  {\n                    ...initialHistoryState.step.enteredBy,\n                    name: \"StepPushed\" as const,\n                  },\n                ]\n              : []),\n          ];\n        }\n\n        function resolvePath() {\n          if (\n            initialContext?.req?.path &&\n            typeof initialContext.req.path === \"string\"\n          ) {\n            return initialContext.req.path as string;\n          }\n\n          if (options.useHash) {\n            return location.hash.split(\"#\")[1] ?? \"/\";\n          }\n\n          return location.pathname + location.search;\n        }\n\n        const path = resolvePath();\n        const activityNames = Object.keys(options.routes);\n\n        if (path) {\n          for (let i = 0; i < activityNames.length; i += 1) {\n            const activityName = activityNames[i] as K;\n            const routes = normalizeRoute(options.routes[activityName]);\n\n            for (let j = 0; j < routes.length; j += 1) {\n              const route = routes[j];\n\n              const template = makeTemplate(route, options.urlPatternOptions);\n              const activityParams = template.parse(path);\n              const matched = !!activityParams;\n\n              if (matched) {\n                const activityId = id();\n\n                return [\n                  makeEvent(\"Pushed\", {\n                    activityId,\n                    activityName,\n                    activityParams: {\n                      ...activityParams,\n                    },\n                    eventDate: new Date().getTime() - MINUTE,\n                    activityContext: {\n                      path,\n                    },\n                  }),\n                ];\n              }\n            }\n          }\n        }\n\n        const fallbackActivityId = id();\n        const fallbackActivityName = options.fallbackActivity({\n          initialContext,\n        });\n        const fallbackActivityRoutes = normalizeRoute(\n          options.routes[fallbackActivityName],\n        );\n        const fallbackActivityPath = fallbackActivityRoutes[0];\n\n        return [\n          makeEvent(\"Pushed\", {\n            activityId: fallbackActivityId,\n            activityName: fallbackActivityName,\n            activityParams: {},\n            eventDate: new Date().getTime() - MINUTE,\n            activityContext: {\n              path: fallbackActivityPath,\n            },\n          }),\n        ];\n      },\n      onInit({ actions: { getStack, dispatchEvent, push, stepPush } }) {\n        const rootActivity = getStack().activities[0];\n\n        const template = makeTemplate(\n          normalizeRoute(options.routes[rootActivity.name])[0],\n          options.urlPatternOptions,\n        );\n\n        const lastStep = last(rootActivity.steps);\n\n        queue(() =>\n          replaceState({\n            history,\n            pathname: template.fill(rootActivity.params),\n            state: {\n              activity: rootActivity,\n              step: lastStep,\n            },\n            useHash: options.useHash,\n          }),\n        );\n\n        const onPopState: Listener = (e) => {\n          if (popFlag) {\n            popFlag -= 1;\n            return;\n          }\n\n          const historyState = safeParseState(e.location.state);\n\n          if (!historyState) {\n            return;\n          }\n\n          const targetActivity = historyState.activity;\n          const targetActivityId = historyState.activity.id;\n          const targetStep = historyState.step;\n\n          const { activities } = getStack();\n          const currentActivity = activities.find(\n            (activity) => activity.isActive,\n          );\n\n          if (!currentActivity) {\n            return;\n          }\n\n          const currentStep = last(currentActivity.steps);\n\n          const nextActivity = activities.find(\n            (activity) => activity.id === targetActivityId,\n          );\n          const nextStep = currentActivity.steps.find(\n            (step) => step.id === targetStep?.id,\n          );\n\n          const isBackward = () => currentActivity.id > targetActivityId;\n          const isForward = () => currentActivity.id < targetActivityId;\n          const isStep = () => currentActivity.id === targetActivityId;\n\n          const isStepBackward = () => {\n            if (!isStep()) {\n              return false;\n            }\n\n            if (!targetStep) {\n              return true;\n            }\n            if (currentStep && currentStep.id > targetStep.id) {\n              return true;\n            }\n\n            return false;\n          };\n          const isStepForward = () => {\n            if (!isStep()) {\n              return false;\n            }\n\n            if (!currentStep) {\n              return true;\n            }\n            if (targetStep && currentStep.id < targetStep.id) {\n              return true;\n            }\n\n            return false;\n          };\n\n          if (isBackward()) {\n            dispatchEvent(\"Popped\", {});\n\n            if (!nextActivity) {\n              pushFlag += 1;\n              push({\n                ...targetActivity.enteredBy,\n              });\n\n              if (\n                targetStep?.enteredBy.name === \"StepPushed\" ||\n                targetStep?.enteredBy.name === \"StepReplaced\"\n              ) {\n                pushFlag += 1;\n                stepPush({\n                  ...targetStep.enteredBy,\n                });\n              }\n            }\n          }\n          if (isStepBackward()) {\n            if (\n              !nextStep &&\n              targetStep &&\n              (targetStep?.enteredBy.name === \"StepPushed\" ||\n                targetStep?.enteredBy.name === \"StepReplaced\")\n            ) {\n              pushFlag += 1;\n              stepPush({\n                ...targetStep.enteredBy,\n              });\n            }\n\n            dispatchEvent(\"StepPopped\", {});\n          }\n\n          if (isForward()) {\n            pushFlag += 1;\n            push({\n              activityId: targetActivity.id,\n              activityName: targetActivity.name,\n              activityParams: targetActivity.params,\n            });\n          }\n          if (isStepForward()) {\n            if (!targetStep) {\n              return;\n            }\n\n            pushFlag += 1;\n            stepPush({\n              stepId: targetStep.id,\n              stepParams: targetStep.params,\n            });\n          }\n        };\n\n        history.listen(onPopState);\n      },\n      onPushed({ effect: { activity } }) {\n        if (pushFlag) {\n          pushFlag -= 1;\n          return;\n        }\n\n        const template = makeTemplate(\n          normalizeRoute(options.routes[activity.name])[0],\n          options.urlPatternOptions,\n        );\n\n        queue(() =>\n          pushState({\n            history,\n            pathname: template.fill(activity.params),\n            state: {\n              activity,\n            },\n            useHash: options.useHash,\n          }),\n        );\n      },\n      onStepPushed({ effect: { activity, step } }) {\n        if (pushFlag) {\n          pushFlag -= 1;\n          return;\n        }\n\n        const template = makeTemplate(\n          normalizeRoute(options.routes[activity.name])[0],\n          options.urlPatternOptions,\n        );\n\n        queue(() =>\n          pushState({\n            history,\n            pathname: template.fill(activity.params),\n            state: {\n              activity,\n              step,\n            },\n            useHash: options.useHash,\n          }),\n        );\n      },\n      onReplaced({ effect: { activity } }) {\n        if (!activity.isActive) {\n          return;\n        }\n\n        const template = makeTemplate(\n          normalizeRoute(options.routes[activity.name])[0],\n          options.urlPatternOptions,\n        );\n\n        queue(() =>\n          replaceState({\n            history,\n            pathname: template.fill(activity.params),\n            state: {\n              activity,\n            },\n            useHash: options.useHash,\n          }),\n        );\n      },\n      onStepReplaced({ effect: { activity, step } }) {\n        if (!activity.isActive) {\n          return;\n        }\n\n        const template = makeTemplate(\n          normalizeRoute(options.routes[activity.name])[0],\n          options.urlPatternOptions,\n        );\n\n        queue(() =>\n          replaceState({\n            history,\n            pathname: template.fill(activity.params),\n            state: {\n              activity,\n              step,\n            },\n            useHash: options.useHash,\n          }),\n        );\n      },\n      onBeforePush({ actionParams, actions: { overrideActionParams } }) {\n        const template = makeTemplate(\n          normalizeRoute(options.routes[actionParams.activityName])[0],\n          options.urlPatternOptions,\n        );\n        const path = template.fill(actionParams.activityParams);\n\n        overrideActionParams({\n          ...actionParams,\n          activityContext: {\n            ...actionParams.activityContext,\n            path,\n          },\n        });\n      },\n      onBeforeReplace({ actionParams, actions: { overrideActionParams } }) {\n        const template = makeTemplate(\n          normalizeRoute(options.routes[actionParams.activityName])[0],\n          options.urlPatternOptions,\n        );\n        const path = template.fill(actionParams.activityParams);\n\n        overrideActionParams({\n          ...actionParams,\n          activityContext: {\n            ...actionParams.activityContext,\n            path,\n          },\n        });\n      },\n      onBeforeStepPop({ actions: { getStack } }) {\n        const { activities } = getStack();\n        const currentActivity = activities.find(\n          (activity) => activity.isActive,\n        );\n\n        if ((currentActivity?.steps.length ?? 0) > 1) {\n          popFlag += 1;\n          queue(history.back);\n        }\n      },\n      onBeforePop({ actions: { getStack } }) {\n        const { activities } = getStack();\n        const currentActivity = activities.find(\n          (activity) => activity.isActive,\n        );\n        const popCount = currentActivity?.steps.length ?? 0;\n\n        popFlag += popCount;\n\n        do {\n          for (let i = 0; i < popCount; i += 1) {\n            queue(history.back);\n          }\n        } while (!safeParseState(getCurrentState({ history })));\n      },\n    };\n  };\n}\n", "import type { Activity, ActivityStep } from \"@stackflow/core\";\nimport type { History } from \"history\";\n\nconst STATE_TAG = `${process.env.PACKAGE_NAME}@${process.env.PACKAGE_VERSION}`;\n\ninterface State {\n  activity: Activity;\n  step?: ActivityStep;\n}\n\ninterface SerializedState extends State {\n  _TAG: typeof STATE_TAG;\n}\n\nfunction serializeStep(step: ActivityStep): ActivityStep {\n  return {\n    ...step,\n    enteredBy:\n      \"activityContext\" in step.enteredBy\n        ? {\n            ...step.enteredBy,\n            activityContext: undefined,\n          }\n        : {\n            ...step.enteredBy,\n          },\n  };\n}\n\nfunction serializeActivity(activity: Activity): Activity {\n  return {\n    ...activity,\n    context: undefined,\n    enteredBy: {\n      ...activity.enteredBy,\n      activityContext: undefined,\n    },\n    steps: activity.steps.map(serializeStep),\n  };\n}\n\nfunction serializeState(state: State): SerializedState {\n  return {\n    _TAG: STATE_TAG,\n    activity: serializeActivity(state.activity),\n    step: state.step ? serializeStep(state.step) : undefined,\n  };\n}\n\nexport function safeParseState(state: unknown): State | null {\n  const _state: any = state;\n\n  if (\n    typeof _state === \"object\" &&\n    _state !== null &&\n    \"_TAG\" in _state &&\n    typeof _state._TAG === \"string\" &&\n    _state._TAG === STATE_TAG\n  ) {\n    return state as State;\n  }\n\n  return null;\n}\n\nexport function getCurrentState({ history }: { history: History }): unknown {\n  return history.location.state;\n}\n\nexport function pushState({\n  history,\n  pathname,\n  state,\n  useHash,\n}: {\n  history: History;\n  pathname: string;\n  state: State;\n  useHash?: boolean;\n}) {\n  const nextPathname = useHash\n    ? `${history.location.pathname}#${pathname}`\n    : pathname;\n\n  history.push(nextPathname, serializeState(state));\n}\n\nexport function replaceState({\n  history,\n  pathname,\n  state,\n  useHash,\n}: {\n  history: History;\n  pathname: string;\n  state: State;\n  useHash?: boolean;\n}) {\n  const nextPathname = useHash\n    ? `${history.location.pathname}#${pathname}`\n    : pathname;\n\n  history.replace(nextPathname, serializeState(state));\n}\n", "export function last<T>(arr: T[]) {\n  return arr.length === 0 ? undefined : arr[arr.length - 1];\n}\n", "import UrlPattern from \"url-pattern\";\n\nfunction pathToUrl(path: string) {\n  return new URL(path, \"file://\");\n}\n\nfunction urlSearchParamsToMap(urlSearchParams: URLSearchParams) {\n  const map: { [key: string]: any } = {};\n\n  urlSearchParams.forEach((value, key) => {\n    map[key] = value;\n  });\n\n  return map;\n}\n\nfunction appendTrailingSlashInPathname(pathname: string) {\n  if (pathname.endsWith(\"/\")) {\n    return pathname;\n  }\n  return `${pathname}/`;\n}\n\nfunction prependQuestionMarkInSearchParams(searchParams: URLSearchParams) {\n  const searchParamsStr = searchParams.toString();\n\n  if (searchParamsStr.length > 0) {\n    return `?${searchParams}`;\n  }\n  return searchParams;\n}\n\n/**\n * import { UrlPatternOptions } from \"url-pattern\"\n */\nexport interface UrlPatternOptions {\n  escapeChar?: string;\n  segmentNameStartChar?: string;\n  segmentValueCharset?: string;\n  segmentNameCharset?: string;\n  optionalSegmentStartChar?: string;\n  optionalSegmentEndChar?: string;\n  wildcardChar?: string;\n}\n\nexport function makeTemplate(\n  templateStr: string,\n  urlPatternOptions?: UrlPatternOptions,\n) {\n  const pattern = new UrlPattern(`${templateStr}(/)`, urlPatternOptions);\n\n  return {\n    fill(params: { [key: string]: string | undefined }) {\n      const pathname = pattern.stringify(params);\n      const pathParams = pattern.match(pathname);\n\n      const searchParamsMap = { ...params };\n\n      Object.keys(pathParams).forEach((key) => {\n        delete searchParamsMap[key];\n      });\n\n      const searchParams = new URLSearchParams(\n        Object.entries(searchParamsMap).reduce(\n          (acc, [key, value]) => ({\n            ...acc,\n            ...(value\n              ? {\n                  [key]: value,\n                }\n              : null),\n          }),\n          {} as Record<string, string>,\n        ),\n      );\n\n      return (\n        appendTrailingSlashInPathname(pathname) +\n        prependQuestionMarkInSearchParams(searchParams)\n      );\n    },\n    parse<T extends { [key: string]: string | undefined }>(\n      path: string,\n    ): T | null {\n      const url = pathToUrl(path);\n      const pathParams = pattern.match(url.pathname);\n      const searchParams = urlSearchParamsToMap(url.searchParams);\n\n      if (!pathParams) {\n        return null;\n      }\n\n      return {\n        ...searchParams,\n        ...pathParams,\n      };\n    },\n  };\n}\n", "export function normalizeRoute(route: string | string[]) {\n  return typeof route === \"string\" ? [route] : route;\n}\n", "import type { History } from \"history\";\n\n/**\n * This function is required to avoid any race conditions caused by asynchronous history updates.\n */\nexport const makeQueue = (history: History) => {\n  let pending = false;\n\n  const queue = (cb: () => void) => {\n    const start = () => {\n      pending = true;\n      const clean = history.listen(() => {\n        clean();\n        pending = false;\n      });\n\n      cb();\n    };\n\n    if (pending) {\n      const clean = history.listen(() => {\n        clean();\n        start();\n      });\n    } else {\n      start();\n    }\n  };\n\n  return queue;\n};\n", "import { createContext, useContext } from \"react\";\n\nexport type RoutesMap = {\n  [activityName in string]?: string | string[];\n};\n\nexport const RoutesContext = createContext<RoutesMap>({});\n\ninterface RoutesProviderProps {\n  routes: RoutesMap;\n  children: React.ReactNode;\n}\nexport const RoutesProvider: React.FC<RoutesProviderProps> = (props) => (\n  <RoutesContext.Provider value={props.routes}>\n    {props.children}\n  </RoutesContext.Provider>\n);\n\nRoutesProvider.displayName = \"RoutesProvider\";\n\nexport function useRoutes() {\n  return useContext(RoutesContext);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,kBAA8B;AAG9B,qBAA0D;;;ACA1D,IAAM,YAAY,GAAG,oCAA4B;AAWjD,SAAS,cAAc,MAAkC;AACvD,SAAO,iCACF,OADE;AAAA,IAEL,WACE,qBAAqB,KAAK,YACtB,iCACK,KAAK,YADV;AAAA,MAEE,iBAAiB;AAAA,IACnB,KACA,mBACK,KAAK;AAAA,EAElB;AACF;AAEA,SAAS,kBAAkB,UAA8B;AACvD,SAAO,iCACF,WADE;AAAA,IAEL,SAAS;AAAA,IACT,WAAW,iCACN,SAAS,YADH;AAAA,MAET,iBAAiB;AAAA,IACnB;AAAA,IACA,OAAO,SAAS,MAAM,IAAI,aAAa;AAAA,EACzC;AACF;AAEA,SAAS,eAAe,OAA+B;AACrD,SAAO;AAAA,IACL,MAAM;AAAA,IACN,UAAU,kBAAkB,MAAM,QAAQ;AAAA,IAC1C,MAAM,MAAM,OAAO,cAAc,MAAM,IAAI,IAAI;AAAA,EACjD;AACF;AAEO,SAAS,eAAe,OAA8B;AAC3D,QAAM,SAAc;AAEpB,MACE,OAAO,WAAW,YAClB,WAAW,QACX,UAAU,UACV,OAAO,OAAO,SAAS,YACvB,OAAO,SAAS,WAChB;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEO,SAAS,gBAAgB,EAAE,QAAQ,GAAkC;AAC1E,SAAO,QAAQ,SAAS;AAC1B;AAEO,SAAS,UAAU;AAAA,EACxB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAKG;AACD,QAAM,eAAe,UACjB,GAAG,QAAQ,SAAS,YAAY,aAChC;AAEJ,UAAQ,KAAK,cAAc,eAAe,KAAK,CAAC;AAClD;AAEO,SAAS,aAAa;AAAA,EAC3B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAKG;AACD,QAAM,eAAe,UACjB,GAAG,QAAQ,SAAS,YAAY,aAChC;AAEJ,UAAQ,QAAQ,cAAc,eAAe,KAAK,CAAC;AACrD;;;ACvGO,SAAS,KAAQ,KAAU;AAChC,SAAO,IAAI,WAAW,IAAI,SAAY,IAAI,IAAI,SAAS,CAAC;AAC1D;;;ACFA,yBAAuB;AAEvB,SAAS,UAAU,MAAc;AAC/B,SAAO,IAAI,IAAI,MAAM,SAAS;AAChC;AAEA,SAAS,qBAAqB,iBAAkC;AAC9D,QAAM,MAA8B,CAAC;AAErC,kBAAgB,QAAQ,CAAC,OAAO,QAAQ;AACtC,QAAI,GAAG,IAAI;AAAA,EACb,CAAC;AAED,SAAO;AACT;AAEA,SAAS,8BAA8B,UAAkB;AACvD,MAAI,SAAS,SAAS,GAAG,GAAG;AAC1B,WAAO;AAAA,EACT;AACA,SAAO,GAAG;AACZ;AAEA,SAAS,kCAAkC,cAA+B;AACxE,QAAM,kBAAkB,aAAa,SAAS;AAE9C,MAAI,gBAAgB,SAAS,GAAG;AAC9B,WAAO,IAAI;AAAA,EACb;AACA,SAAO;AACT;AAeO,SAAS,aACd,aACA,mBACA;AACA,QAAM,UAAU,IAAI,mBAAAA,QAAW,GAAG,kBAAkB,iBAAiB;AAErE,SAAO;AAAA,IACL,KAAK,QAA+C;AAClD,YAAM,WAAW,QAAQ,UAAU,MAAM;AACzC,YAAM,aAAa,QAAQ,MAAM,QAAQ;AAEzC,YAAM,kBAAkB,mBAAK;AAE7B,aAAO,KAAK,UAAU,EAAE,QAAQ,CAAC,QAAQ;AACvC,eAAO,gBAAgB,GAAG;AAAA,MAC5B,CAAC;AAED,YAAM,eAAe,IAAI;AAAA,QACvB,OAAO,QAAQ,eAAe,EAAE;AAAA,UAC9B,CAAC,KAAK,CAAC,KAAK,KAAK,MAAO,kCACnB,MACC,QACA;AAAA,YACE,CAAC,GAAG,GAAG;AAAA,UACT,IACA;AAAA,UAEN,CAAC;AAAA,QACH;AAAA,MACF;AAEA,aACE,8BAA8B,QAAQ,IACtC,kCAAkC,YAAY;AAAA,IAElD;AAAA,IACA,MACE,MACU;AACV,YAAM,MAAM,UAAU,IAAI;AAC1B,YAAM,aAAa,QAAQ,MAAM,IAAI,QAAQ;AAC7C,YAAM,eAAe,qBAAqB,IAAI,YAAY;AAE1D,UAAI,CAAC,YAAY;AACf,eAAO;AAAA,MACT;AAEA,aAAO,kCACF,eACA;AAAA,IAEP;AAAA,EACF;AACF;;;AClGO,SAAS,eAAe,OAA0B;AACvD,SAAO,OAAO,UAAU,WAAW,CAAC,KAAK,IAAI;AAC/C;;;ACGO,IAAM,YAAY,CAAC,YAAqB;AAC7C,MAAI,UAAU;AAEd,QAAM,QAAQ,CAAC,OAAmB;AAChC,UAAM,QAAQ,MAAM;AAClB,gBAAU;AACV,YAAM,QAAQ,QAAQ,OAAO,MAAM;AACjC,cAAM;AACN,kBAAU;AAAA,MACZ,CAAC;AAED,SAAG;AAAA,IACL;AAEA,QAAI,SAAS;AACX,YAAM,QAAQ,QAAQ,OAAO,MAAM;AACjC,cAAM;AACN,cAAM;AAAA,MACR,CAAC;AAAA,IACH,OAAO;AACL,YAAM;AAAA,IACR;AAAA,EACF;AAEA,SAAO;AACT;;;AC9BA,mBAA0C;AAaxC;AAPK,IAAM,oBAAgB,4BAAyB,CAAC,CAAC;AAMjD,IAAM,iBAAgD,CAAC,UAC5D,4CAAC,cAAc,UAAd,EAAuB,OAAO,MAAM,QAClC,gBAAM,UACT;AAGF,eAAe,cAAc;AAEtB,SAAS,YAAY;AAC1B,aAAO,yBAAW,aAAa;AACjC;;;ANmCU,IAAAC,sBAAA;AAvCV,IAAM,SAAS;AACf,IAAM,SAAS,KAAK;AAWb,SAAS,kBAGd,SACyB;AAlC3B;AAqCE,QAAM,WACJ,aAAQ,YAAR,YACC,OAAO,WAAW,kBACf,oCAAoB,CAAC,CAAC,QACtB,qCAAqB;AAAA,IACnB;AAAA,EACF,CAAC;AAEP,QAAM,EAAE,SAAS,IAAI;AAErB,SAAO,MAAM;AACX,QAAI,WAAW;AACf,QAAI,UAAU;AAEd,UAAM,QAAQ,UAAU,OAAO;AAE/B,WAAO;AAAA,MACL,KAAK;AAAA,MACL,UAAU,EAAE,MAAM,GAAG;AACnB,eACE,6CAAC,kBAAe,QAAQ,QAAQ,QAC7B,gBAAM,OAAO,GAChB;AAAA,MAEJ;AAAA,MACA,sBAAsB,EAAE,eAAe,GAAG;AA9DhD,YAAAC,KAAA;AA+DQ,cAAM,sBAAsB;AAAA,UAC1B,gBAAgB,EAAE,QAAQ,CAAC;AAAA,QAC7B;AAEA,YAAI,qBAAqB;AACvB,iBAAO;AAAA,YACL,iCACK,oBAAoB,SAAS,YADlC;AAAA,cAEE,MAAM;AAAA,YACR;AAAA,YACA,KAAIA,MAAA,oBAAoB,SAApB,gBAAAA,IAA0B,UAAU,UAAS,kBACjD,yBAAoB,SAApB,mBAA0B,UAAU,UAAS,iBACzC;AAAA,cACE,iCACK,oBAAoB,KAAK,YAD9B;AAAA,gBAEE,MAAM;AAAA,cACR;AAAA,YACF,IACA,CAAC;AAAA,UACP;AAAA,QACF;AAEA,iBAAS,cAAc;AArF/B,cAAAA,KAAAC;AAsFU,gBACED,MAAA,iDAAgB,QAAhB,gBAAAA,IAAqB,SACrB,OAAO,eAAe,IAAI,SAAS,UACnC;AACA,mBAAO,eAAe,IAAI;AAAA,UAC5B;AAEA,cAAI,QAAQ,SAAS;AACnB,oBAAOC,MAAA,SAAS,KAAK,MAAM,GAAG,EAAE,CAAC,MAA1B,OAAAA,MAA+B;AAAA,UACxC;AAEA,iBAAO,SAAS,WAAW,SAAS;AAAA,QACtC;AAEA,cAAM,OAAO,YAAY;AACzB,cAAM,gBAAgB,OAAO,KAAK,QAAQ,MAAM;AAEhD,YAAI,MAAM;AACR,mBAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK,GAAG;AAChD,kBAAM,eAAe,cAAc,CAAC;AACpC,kBAAM,SAAS,eAAe,QAAQ,OAAO,YAAY,CAAC;AAE1D,qBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GAAG;AACzC,oBAAM,QAAQ,OAAO,CAAC;AAEtB,oBAAM,WAAW,aAAa,OAAO,QAAQ,iBAAiB;AAC9D,oBAAM,iBAAiB,SAAS,MAAM,IAAI;AAC1C,oBAAM,UAAU,CAAC,CAAC;AAElB,kBAAI,SAAS;AACX,sBAAM,iBAAa,gBAAG;AAEtB,uBAAO;AAAA,sBACL,uBAAU,UAAU;AAAA,oBAClB;AAAA,oBACA;AAAA,oBACA,gBAAgB,mBACX;AAAA,oBAEL,WAAW,IAAI,KAAK,EAAE,QAAQ,IAAI;AAAA,oBAClC,iBAAiB;AAAA,sBACf;AAAA,oBACF;AAAA,kBACF,CAAC;AAAA,gBACH;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAEA,cAAM,yBAAqB,gBAAG;AAC9B,cAAM,uBAAuB,QAAQ,iBAAiB;AAAA,UACpD;AAAA,QACF,CAAC;AACD,cAAM,yBAAyB;AAAA,UAC7B,QAAQ,OAAO,oBAAoB;AAAA,QACrC;AACA,cAAM,uBAAuB,uBAAuB,CAAC;AAErD,eAAO;AAAA,cACL,uBAAU,UAAU;AAAA,YAClB,YAAY;AAAA,YACZ,cAAc;AAAA,YACd,gBAAgB,CAAC;AAAA,YACjB,WAAW,IAAI,KAAK,EAAE,QAAQ,IAAI;AAAA,YAClC,iBAAiB;AAAA,cACf,MAAM;AAAA,YACR;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,MACA,OAAO,EAAE,SAAS,EAAE,UAAU,eAAe,MAAM,SAAS,EAAE,GAAG;AAC/D,cAAM,eAAe,SAAS,EAAE,WAAW,CAAC;AAE5C,cAAM,WAAW;AAAA,UACf,eAAe,QAAQ,OAAO,aAAa,IAAI,CAAC,EAAE,CAAC;AAAA,UACnD,QAAQ;AAAA,QACV;AAEA,cAAM,WAAW,KAAK,aAAa,KAAK;AAExC;AAAA,UAAM,MACJ,aAAa;AAAA,YACX;AAAA,YACA,UAAU,SAAS,KAAK,aAAa,MAAM;AAAA,YAC3C,OAAO;AAAA,cACL,UAAU;AAAA,cACV,MAAM;AAAA,YACR;AAAA,YACA,SAAS,QAAQ;AAAA,UACnB,CAAC;AAAA,QACH;AAEA,cAAM,aAAuB,CAAC,MAAM;AAClC,cAAI,SAAS;AACX,uBAAW;AACX;AAAA,UACF;AAEA,gBAAM,eAAe,eAAe,EAAE,SAAS,KAAK;AAEpD,cAAI,CAAC,cAAc;AACjB;AAAA,UACF;AAEA,gBAAM,iBAAiB,aAAa;AACpC,gBAAM,mBAAmB,aAAa,SAAS;AAC/C,gBAAM,aAAa,aAAa;AAEhC,gBAAM,EAAE,WAAW,IAAI,SAAS;AAChC,gBAAM,kBAAkB,WAAW;AAAA,YACjC,CAAC,aAAa,SAAS;AAAA,UACzB;AAEA,cAAI,CAAC,iBAAiB;AACpB;AAAA,UACF;AAEA,gBAAM,cAAc,KAAK,gBAAgB,KAAK;AAE9C,gBAAM,eAAe,WAAW;AAAA,YAC9B,CAAC,aAAa,SAAS,OAAO;AAAA,UAChC;AACA,gBAAM,WAAW,gBAAgB,MAAM;AAAA,YACrC,CAAC,SAAS,KAAK,QAAO,yCAAY;AAAA,UACpC;AAEA,gBAAM,aAAa,MAAM,gBAAgB,KAAK;AAC9C,gBAAM,YAAY,MAAM,gBAAgB,KAAK;AAC7C,gBAAM,SAAS,MAAM,gBAAgB,OAAO;AAE5C,gBAAM,iBAAiB,MAAM;AAC3B,gBAAI,CAAC,OAAO,GAAG;AACb,qBAAO;AAAA,YACT;AAEA,gBAAI,CAAC,YAAY;AACf,qBAAO;AAAA,YACT;AACA,gBAAI,eAAe,YAAY,KAAK,WAAW,IAAI;AACjD,qBAAO;AAAA,YACT;AAEA,mBAAO;AAAA,UACT;AACA,gBAAM,gBAAgB,MAAM;AAC1B,gBAAI,CAAC,OAAO,GAAG;AACb,qBAAO;AAAA,YACT;AAEA,gBAAI,CAAC,aAAa;AAChB,qBAAO;AAAA,YACT;AACA,gBAAI,cAAc,YAAY,KAAK,WAAW,IAAI;AAChD,qBAAO;AAAA,YACT;AAEA,mBAAO;AAAA,UACT;AAEA,cAAI,WAAW,GAAG;AAChB,0BAAc,UAAU,CAAC,CAAC;AAE1B,gBAAI,CAAC,cAAc;AACjB,0BAAY;AACZ,mBAAK,mBACA,eAAe,UACnB;AAED,mBACE,yCAAY,UAAU,UAAS,iBAC/B,yCAAY,UAAU,UAAS,gBAC/B;AACA,4BAAY;AACZ,yBAAS,mBACJ,WAAW,UACf;AAAA,cACH;AAAA,YACF;AAAA,UACF;AACA,cAAI,eAAe,GAAG;AACpB,gBACE,CAAC,YACD,gBACC,yCAAY,UAAU,UAAS,iBAC9B,yCAAY,UAAU,UAAS,iBACjC;AACA,0BAAY;AACZ,uBAAS,mBACJ,WAAW,UACf;AAAA,YACH;AAEA,0BAAc,cAAc,CAAC,CAAC;AAAA,UAChC;AAEA,cAAI,UAAU,GAAG;AACf,wBAAY;AACZ,iBAAK;AAAA,cACH,YAAY,eAAe;AAAA,cAC3B,cAAc,eAAe;AAAA,cAC7B,gBAAgB,eAAe;AAAA,YACjC,CAAC;AAAA,UACH;AACA,cAAI,cAAc,GAAG;AACnB,gBAAI,CAAC,YAAY;AACf;AAAA,YACF;AAEA,wBAAY;AACZ,qBAAS;AAAA,cACP,QAAQ,WAAW;AAAA,cACnB,YAAY,WAAW;AAAA,YACzB,CAAC;AAAA,UACH;AAAA,QACF;AAEA,gBAAQ,OAAO,UAAU;AAAA,MAC3B;AAAA,MACA,SAAS,EAAE,QAAQ,EAAE,SAAS,EAAE,GAAG;AACjC,YAAI,UAAU;AACZ,sBAAY;AACZ;AAAA,QACF;AAEA,cAAM,WAAW;AAAA,UACf,eAAe,QAAQ,OAAO,SAAS,IAAI,CAAC,EAAE,CAAC;AAAA,UAC/C,QAAQ;AAAA,QACV;AAEA;AAAA,UAAM,MACJ,UAAU;AAAA,YACR;AAAA,YACA,UAAU,SAAS,KAAK,SAAS,MAAM;AAAA,YACvC,OAAO;AAAA,cACL;AAAA,YACF;AAAA,YACA,SAAS,QAAQ;AAAA,UACnB,CAAC;AAAA,QACH;AAAA,MACF;AAAA,MACA,aAAa,EAAE,QAAQ,EAAE,UAAU,KAAK,EAAE,GAAG;AAC3C,YAAI,UAAU;AACZ,sBAAY;AACZ;AAAA,QACF;AAEA,cAAM,WAAW;AAAA,UACf,eAAe,QAAQ,OAAO,SAAS,IAAI,CAAC,EAAE,CAAC;AAAA,UAC/C,QAAQ;AAAA,QACV;AAEA;AAAA,UAAM,MACJ,UAAU;AAAA,YACR;AAAA,YACA,UAAU,SAAS,KAAK,SAAS,MAAM;AAAA,YACvC,OAAO;AAAA,cACL;AAAA,cACA;AAAA,YACF;AAAA,YACA,SAAS,QAAQ;AAAA,UACnB,CAAC;AAAA,QACH;AAAA,MACF;AAAA,MACA,WAAW,EAAE,QAAQ,EAAE,SAAS,EAAE,GAAG;AACnC,YAAI,CAAC,SAAS,UAAU;AACtB;AAAA,QACF;AAEA,cAAM,WAAW;AAAA,UACf,eAAe,QAAQ,OAAO,SAAS,IAAI,CAAC,EAAE,CAAC;AAAA,UAC/C,QAAQ;AAAA,QACV;AAEA;AAAA,UAAM,MACJ,aAAa;AAAA,YACX;AAAA,YACA,UAAU,SAAS,KAAK,SAAS,MAAM;AAAA,YACvC,OAAO;AAAA,cACL;AAAA,YACF;AAAA,YACA,SAAS,QAAQ;AAAA,UACnB,CAAC;AAAA,QACH;AAAA,MACF;AAAA,MACA,eAAe,EAAE,QAAQ,EAAE,UAAU,KAAK,EAAE,GAAG;AAC7C,YAAI,CAAC,SAAS,UAAU;AACtB;AAAA,QACF;AAEA,cAAM,WAAW;AAAA,UACf,eAAe,QAAQ,OAAO,SAAS,IAAI,CAAC,EAAE,CAAC;AAAA,UAC/C,QAAQ;AAAA,QACV;AAEA;AAAA,UAAM,MACJ,aAAa;AAAA,YACX;AAAA,YACA,UAAU,SAAS,KAAK,SAAS,MAAM;AAAA,YACvC,OAAO;AAAA,cACL;AAAA,cACA;AAAA,YACF;AAAA,YACA,SAAS,QAAQ;AAAA,UACnB,CAAC;AAAA,QACH;AAAA,MACF;AAAA,MACA,aAAa,EAAE,cAAc,SAAS,EAAE,qBAAqB,EAAE,GAAG;AAChE,cAAM,WAAW;AAAA,UACf,eAAe,QAAQ,OAAO,aAAa,YAAY,CAAC,EAAE,CAAC;AAAA,UAC3D,QAAQ;AAAA,QACV;AACA,cAAM,OAAO,SAAS,KAAK,aAAa,cAAc;AAEtD,6BAAqB,iCAChB,eADgB;AAAA,UAEnB,iBAAiB,iCACZ,aAAa,kBADD;AAAA,YAEf;AAAA,UACF;AAAA,QACF,EAAC;AAAA,MACH;AAAA,MACA,gBAAgB,EAAE,cAAc,SAAS,EAAE,qBAAqB,EAAE,GAAG;AACnE,cAAM,WAAW;AAAA,UACf,eAAe,QAAQ,OAAO,aAAa,YAAY,CAAC,EAAE,CAAC;AAAA,UAC3D,QAAQ;AAAA,QACV;AACA,cAAM,OAAO,SAAS,KAAK,aAAa,cAAc;AAEtD,6BAAqB,iCAChB,eADgB;AAAA,UAEnB,iBAAiB,iCACZ,aAAa,kBADD;AAAA,YAEf;AAAA,UACF;AAAA,QACF,EAAC;AAAA,MACH;AAAA,MACA,gBAAgB,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG;AAvajD,YAAAD;AAwaQ,cAAM,EAAE,WAAW,IAAI,SAAS;AAChC,cAAM,kBAAkB,WAAW;AAAA,UACjC,CAAC,aAAa,SAAS;AAAA,QACzB;AAEA,cAAKA,MAAA,mDAAiB,MAAM,WAAvB,OAAAA,MAAiC,KAAK,GAAG;AAC5C,qBAAW;AACX,gBAAM,QAAQ,IAAI;AAAA,QACpB;AAAA,MACF;AAAA,MACA,YAAY,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG;AAlb7C,YAAAA;AAmbQ,cAAM,EAAE,WAAW,IAAI,SAAS;AAChC,cAAM,kBAAkB,WAAW;AAAA,UACjC,CAAC,aAAa,SAAS;AAAA,QACzB;AACA,cAAM,YAAWA,MAAA,mDAAiB,MAAM,WAAvB,OAAAA,MAAiC;AAElD,mBAAW;AAEX,WAAG;AACD,mBAAS,IAAI,GAAG,IAAI,UAAU,KAAK,GAAG;AACpC,kBAAM,QAAQ,IAAI;AAAA,UACpB;AAAA,QACF,SAAS,CAAC,eAAe,gBAAgB,EAAE,QAAQ,CAAC,CAAC;AAAA,MACvD;AAAA,IACF;AAAA,EACF;AACF;",
  "names": ["UrlPattern", "import_jsx_runtime", "_a", "_b"]
}
