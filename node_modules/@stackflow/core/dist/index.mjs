var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// src/utils/compareBy.ts
function compareBy(a, b, selector) {
  const $a = selector(a);
  const $b = selector(b);
  if ($a < $b) {
    return -1;
  }
  if ($a === $b) {
    return 0;
  }
  return 1;
}

// src/utils/findIndices.ts
function findIndices(arr, compare) {
  return arr.map((e, i) => compare(e) ? i : void 0).filter((output) => typeof output === "number");
}

// src/utils/time.ts
var dt = 0;
var memt = 0;
var time = () => {
  const t = new Date().getTime();
  if (memt === t) {
    dt += 1;
  } else {
    memt = t;
    dt = 0;
  }
  return (t * 1e3 + dt) / 1e3;
};

// src/utils/id.ts
function id() {
  return (time() * 1e3).toString(16);
}

// src/utils/last.ts
function last(arr) {
  return arr.length === 0 ? void 0 : arr[arr.length - 1];
}

// src/utils/omit.ts
function omit(obj, fields) {
  const output = __spreadValues({}, obj);
  fields.forEach((field) => {
    delete output[field];
  });
  return output;
}

// src/utils/once.ts
function once(cb) {
  let called = false;
  return () => {
    if (called) {
      return;
    }
    called = true;
    cb();
  };
}

// src/utils/uniqBy.ts
function uniqBy(arr, by) {
  const valueMap = /* @__PURE__ */ new Map();
  return [...arr].reverse().filter((item) => {
    const key = by(item);
    if (key === null) {
      return true;
    }
    const exists = !!valueMap.get(key);
    valueMap.set(key, true);
    return !exists;
  }).reverse();
}

// src/activity-utils/findTargetActivityIndexes.ts
function isActivityNotExited(activity) {
  return !activity.exitedBy;
}
function compareActivitiesByEventDate(a1, a2) {
  return a2.enteredBy.eventDate - a1.enteredBy.eventDate;
}
function findLatestActiveActivity(activities) {
  return activities.filter(isActivityNotExited).sort(compareActivitiesByEventDate)[0];
}
function findTargetActivityIndexes(activities, event, isTransitionDone) {
  const targetActivities = [];
  switch (event.name) {
    case "Replaced": {
      const alreadyExistingActivityIndex = last(
        findIndices(activities, (activity) => activity.id === event.activityId)
      );
      if (alreadyExistingActivityIndex !== void 0) {
        break;
      }
      const sorted = activities.slice().sort(compareActivitiesByEventDate).filter(isActivityNotExited);
      const transitionState = event.skipEnterActiveState || isTransitionDone ? "enter-done" : "enter-active";
      if (transitionState === "enter-done") {
        const range = sorted.findIndex(
          (activity) => !(event.skipEnterActiveState && activity.enteredBy.name === "Replaced" && activity.transitionState === "enter-active")
        );
        return sorted.slice(0, range + 1).map((a) => activities.indexOf(a));
      }
      break;
    }
    case "Popped": {
      const latestActivity = findLatestActiveActivity(activities.slice(1));
      if (latestActivity) {
        targetActivities.push(activities.indexOf(latestActivity));
      }
      break;
    }
    case "StepPushed":
    case "StepReplaced": {
      const latestActivity = findLatestActiveActivity(activities);
      if (latestActivity) {
        targetActivities.push(activities.indexOf(latestActivity));
      }
      break;
    }
    case "StepPopped": {
      const latestActivity = findLatestActiveActivity(activities);
      if (latestActivity && latestActivity.steps.length > 1) {
        targetActivities.push(activities.indexOf(latestActivity));
      }
      break;
    }
    default:
      break;
  }
  return targetActivities;
}

// src/activity-utils/createActivityFromEvent.ts
var createActivityFromEvent = (event, transitionState) => ({
  id: event.activityId,
  name: event.activityName,
  transitionState,
  params: event.activityParams,
  context: event.activityContext,
  steps: [
    {
      id: event.activityId,
      params: event.activityParams,
      enteredBy: event
    }
  ],
  enteredBy: event,
  isTop: false,
  isActive: false,
  isRoot: false,
  zIndex: -1
});

// src/activity-utils/createReducer.ts
function createReducer(reducerMap) {
  return (activity, event) => {
    const reducer = reducerMap[event.name];
    if (reducer) {
      return reducer(activity, event);
    }
    throw new Error(`No reducer for event ${JSON.stringify(event)}`);
  };
}

// src/activity-utils/findNewActivityIndex.ts
function findNewActivityIndex(event, activities) {
  switch (event.name) {
    case "Pushed":
      return activities.length;
    case "Replaced": {
      const alreadyExistingActivityIndex = last(
        findIndices(activities, (activity) => activity.id === event.activityId)
      );
      return alreadyExistingActivityIndex != null ? alreadyExistingActivityIndex : activities.length;
    }
    default:
      return -1;
  }
}

// src/activity-utils/makeActivitiesReducers.ts
var makeActivitiesReducers = (isTransitionDone) => createReducer({
  /**
   * noop
   */
  Initialized: (activities, event) => activities,
  /**
   * noop
   */
  ActivityRegistered: (activities, event) => activities,
  /**
   * Push new activity to activities
   */
  Pushed: (activities, event) => {
    const transitionState = event.skipEnterActiveState || isTransitionDone ? "enter-done" : "enter-active";
    const reservedIndex = findNewActivityIndex(event, activities);
    return [
      ...activities.slice(0, reservedIndex),
      createActivityFromEvent(event, transitionState),
      ...activities.slice(reservedIndex + 1)
    ];
  },
  /**
   * Replace activity at reservedIndex with new activity
   */
  Replaced: (activities, event) => {
    var _a, _b;
    const reservedIndex = findNewActivityIndex(event, activities);
    const transitionState = (_b = (_a = activities[reservedIndex]) == null ? void 0 : _a.transitionState) != null ? _b : event.skipEnterActiveState || isTransitionDone ? "enter-done" : "enter-active";
    return [
      ...activities.slice(0, reservedIndex),
      createActivityFromEvent(event, transitionState),
      ...activities.slice(reservedIndex + 1)
    ];
  },
  /**
   * noop
   */
  Popped: (activities, event) => activities,
  /**
   * noop
   */
  StepPushed: (activities, event) => activities,
  /**
   * noop
   */
  StepReplaced: (activities, event) => activities,
  /**
   * noop
   */
  StepPopped: (activities, event) => activities
});

// src/activity-utils/makeActivityReducers.ts
var makeActivityReducers = (isTransitionDone) => createReducer({
  /**
   * noop
   */
  Initialized: (activity, event) => activity,
  /**
   * noop
   */
  ActivityRegistered: (activity, event) => activity,
  /**
   * noop
   */
  Pushed: (activity, event) => activity,
  /**
   * Change transition state to exit-done
   */
  Replaced: (activity, event) => __spreadProps(__spreadValues({}, activity), {
    exitedBy: event,
    transitionState: "exit-done"
  }),
  /**
   * Change transition state to exit-done or exit-active depending on skipExitActiveState
   */
  Popped: (activity, event) => {
    const transitionState = event.skipExitActiveState || isTransitionDone ? "exit-done" : "exit-active";
    return __spreadProps(__spreadValues({}, activity), {
      exitedBy: event,
      transitionState,
      params: transitionState === "exit-done" ? activity.steps[0].params : activity.params,
      steps: transitionState === "exit-done" ? [activity.steps[0]] : activity.steps
    });
  },
  /**
   * Replace step params
   * Push new step
   */
  StepPushed: (activity, event) => {
    const newRoute = {
      id: event.stepId,
      params: event.stepParams,
      enteredBy: event
    };
    return __spreadProps(__spreadValues({}, activity), {
      params: event.stepParams,
      steps: [...activity.steps, newRoute]
    });
  },
  /**
   * Replace step params
   * Replace the last step
   */
  StepReplaced: (activity, event) => {
    const newRoute = {
      id: event.stepId,
      params: event.stepParams,
      enteredBy: event
    };
    return __spreadProps(__spreadValues({}, activity), {
      params: event.stepParams,
      steps: [
        ...activity.steps.slice(0, activity.steps.length - 1),
        newRoute
      ]
    });
  },
  /**
   * Pop the last step
   * If there are params in the previous step, set them as the new params
   */
  StepPopped: (activity, event) => {
    var _a;
    activity.steps.pop();
    const beforeActivityParams = (_a = last(activity.steps)) == null ? void 0 : _a.params;
    return __spreadProps(__spreadValues({}, activity), {
      params: beforeActivityParams != null ? beforeActivityParams : activity.params
    });
  }
});

// src/event-utils/filterEvents.ts
function filterEvents(events, eventName) {
  return events.filter((e) => e.name === eventName);
}

// src/event-utils/makeEvent.ts
function makeEvent(name, parameters) {
  return __spreadProps(__spreadValues({
    id: id(),
    eventDate: time()
  }, parameters), {
    name
  });
}

// src/event-utils/validateEvents.ts
function validateEvents(events) {
  if (events.length === 0) {
    throw new Error("events parameter is empty");
  }
  const initEvents = filterEvents(events, "Initialized");
  if (initEvents.length > 1) {
    throw new Error("InitializedEvent can only exist once");
  }
  const activityRegisteredEvents = filterEvents(events, "ActivityRegistered");
  const registeredActivityNames = new Set(
    activityRegisteredEvents.map((e) => e.activityName)
  );
  const pushedEvents = filterEvents(events, "Pushed");
  if (pushedEvents.some((e) => !registeredActivityNames.has(e.activityName))) {
    throw new Error("the corresponding activity does not exist");
  }
}

// src/aggregate.ts
function aggregate(events, now) {
  const sortedEvents = uniqBy(
    [...events].sort((a, b) => compareBy(a, b, (e) => e.id)),
    (e) => e.id
  );
  validateEvents(sortedEvents);
  const initEvent = filterEvents(sortedEvents, "Initialized")[0];
  const activityRegisteredEvents = filterEvents(events, "ActivityRegistered");
  const { transitionDuration } = initEvent;
  const activities = sortedEvents.reduce(
    (activities2, event) => {
      const isTransitionDone = now - event.eventDate >= transitionDuration;
      const targets = findTargetActivityIndexes(
        activities2,
        event,
        isTransitionDone
      );
      const activityReducer = makeActivityReducers(isTransitionDone);
      const activitiesReducer = makeActivitiesReducers(isTransitionDone);
      const newActivities = activitiesReducer(activities2, event);
      targets.forEach((targetIdx) => {
        newActivities[targetIdx] = activityReducer(
          newActivities[targetIdx],
          event
        );
      });
      return newActivities;
    },
    []
  );
  const uniqActivities = uniqBy(activities, (activity) => activity.id);
  const visibleActivities = uniqActivities.filter(
    (activity) => activity.transitionState === "enter-active" || activity.transitionState === "enter-done" || activity.transitionState === "exit-active"
  );
  const enteredActivities = visibleActivities.filter(
    (activity) => activity.transitionState === "enter-active" || activity.transitionState === "enter-done"
  );
  const lastVisibleActivity = visibleActivities[visibleActivities.length - 1];
  const lastEnteredActivity = enteredActivities[enteredActivities.length - 1];
  const globalTransitionState = activities.find(
    (activity) => activity.transitionState === "enter-active" || activity.transitionState === "exit-active"
  ) ? "loading" : "idle";
  const output = {
    activities: uniqActivities.map((activity) => {
      const zIndex = visibleActivities.findIndex(
        ({ id: id2 }) => id2 === activity.id
      );
      return __spreadValues(__spreadProps(__spreadValues({
        id: activity.id,
        name: activity.name,
        transitionState: activity.transitionState,
        params: activity.params,
        steps: activity.steps,
        enteredBy: activity.enteredBy
      }, activity.exitedBy ? {
        exitedBy: activity.exitedBy
      } : null), {
        isTop: (lastVisibleActivity == null ? void 0 : lastVisibleActivity.id) === activity.id,
        isActive: (lastEnteredActivity == null ? void 0 : lastEnteredActivity.id) === activity.id,
        isRoot: zIndex === 0 || zIndex === 1 && activity.transitionState === "enter-active" && activity.enteredBy.name === "Replaced",
        zIndex
      }), activity.context ? {
        context: activity.context
      } : null);
    }).sort((a, b) => compareBy(a, b, (activity) => activity.id)),
    registeredActivities: activityRegisteredEvents.map((event) => __spreadValues({
      name: event.activityName
    }, event.activityParamsSchema ? {
      paramsSchema: event.activityParamsSchema
    } : null)),
    transitionDuration,
    globalTransitionState
  };
  return output;
}

// src/makeCoreStore.ts
import isEqual2 from "react-fast-compare";

// src/produceEffects.ts
import isEqual from "react-fast-compare";
function produceEffects(prevOutput, nextOutput) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const output = [];
  const somethingChanged = !isEqual(prevOutput, nextOutput);
  if (somethingChanged) {
    output.push({
      _TAG: "%SOMETHING_CHANGED%"
    });
  }
  for (let i = 0; i < Math.max(prevOutput.activities.length, nextOutput.activities.length); i += 1) {
    const prevActivity = prevOutput.activities[i];
    const nextActivity = nextOutput.activities[i];
    const isPrevActivityPopped = (prevActivity == null ? void 0 : prevActivity.transitionState) === "exit-done" || (prevActivity == null ? void 0 : prevActivity.transitionState) === "exit-active";
    const isNextActivityPushed = (nextActivity == null ? void 0 : nextActivity.transitionState) === "enter-active" || (nextActivity == null ? void 0 : nextActivity.transitionState) === "enter-done";
    if (prevActivity && nextActivity && prevActivity.id === nextActivity.id) {
      for (let j = 0; j < Math.max(
        ((_a = prevActivity.steps) != null ? _a : []).length,
        ((_b = nextActivity.steps) != null ? _b : []).length
      ); j += 1) {
        const prevStep = prevActivity.steps[j];
        const nextStep = nextActivity.steps[j];
        if (!prevStep && nextStep) {
          output.push({
            _TAG: "STEP_PUSHED",
            activity: nextActivity,
            step: nextStep
          });
        } else if (prevStep && !nextStep) {
          output.push({
            _TAG: "STEP_POPPED",
            activity: nextActivity
          });
        } else if (prevActivity.steps.length === nextActivity.steps.length && prevStep.id !== nextStep.id) {
          output.push({
            _TAG: "STEP_REPLACED",
            activity: nextActivity,
            step: nextStep
          });
        }
      }
    }
    if (!prevActivity && nextActivity) {
      output.push({
        _TAG: nextActivity.enteredBy.name === "Pushed" ? "PUSHED" : "REPLACED",
        activity: nextActivity
      });
    } else if (isPrevActivityPopped && isNextActivityPushed) {
      output.push({
        _TAG: nextActivity.enteredBy.name === "Pushed" ? "PUSHED" : "REPLACED",
        activity: nextActivity
      });
    } else if (prevActivity && nextActivity && prevActivity.id === nextActivity.id && !isEqual(
      omit(prevActivity, [
        "isActive",
        "isTop",
        "isRoot",
        "transitionState",
        "zIndex"
      ]),
      omit(nextActivity, [
        "isActive",
        "isTop",
        "isRoot",
        "transitionState",
        "zIndex"
      ])
    ) && nextActivity.enteredBy.name === "Replaced" && !isEqual(prevActivity.enteredBy, nextActivity.enteredBy)) {
      output.push({
        _TAG: "REPLACED",
        activity: nextActivity
      });
    }
  }
  for (let j = Math.max(prevOutput.activities.length, nextOutput.activities.length) - 1; j >= 0; j -= 1) {
    const isPrevActivityPushed = ((_c = prevOutput.activities[j]) == null ? void 0 : _c.transitionState) === "enter-done" || ((_d = prevOutput.activities[j]) == null ? void 0 : _d.transitionState) === "enter-active";
    const isNextActivityPopped = ((_e = nextOutput.activities[j]) == null ? void 0 : _e.transitionState) === "exit-active" || ((_f = nextOutput.activities[j]) == null ? void 0 : _f.transitionState) === "exit-done";
    const isReplacedEvent = ((_g = nextOutput.activities[j + 1]) == null ? void 0 : _g.enteredBy.name) === "Replaced" && ((_h = nextOutput.activities[j + 1]) == null ? void 0 : _h.transitionState) === "enter-done";
    if (isPrevActivityPushed && isNextActivityPopped && !isReplacedEvent) {
      output.push({
        _TAG: "POPPED",
        activity: nextOutput.activities[j]
      });
    }
  }
  return output;
}

// src/makeCoreStore.ts
var SECOND = 1e3;
var INTERVAL_MS = SECOND / 60;
function makeCoreStore(options) {
  const events = {
    value: [...options.initialEvents]
  };
  const stack = {
    value: aggregate(events.value, new Date().getTime())
  };
  const storeListeners = [];
  const defaultPlugin = () => ({
    key: "@stackflow/core",
    onChanged() {
      storeListeners.forEach((listener) => listener());
    }
  });
  const pluginInstances = [
    defaultPlugin(),
    ...options.plugins.map((plugin) => plugin())
  ];
  const setStackValue = (nextStackValue) => {
    const effects = produceEffects(stack.value, nextStackValue);
    stack.value = nextStackValue;
    triggerPostEffectHooks(effects, pluginInstances);
  };
  const dispatchEvent = (name, params) => {
    const newEvent = makeEvent(name, params);
    const nextStackValue = aggregate(
      [...events.value, newEvent],
      new Date().getTime()
    );
    events.value.push(newEvent);
    setStackValue(nextStackValue);
    const interval = setInterval(() => {
      const nextStackValue2 = aggregate(events.value, new Date().getTime());
      if (!isEqual2(stack.value, nextStackValue2)) {
        setStackValue(nextStackValue2);
      }
      if (nextStackValue2.globalTransitionState === "idle") {
        clearInterval(interval);
      }
    }, INTERVAL_MS);
  };
  function triggerPreEffectHooks(event, plugins) {
    let isPrevented = false;
    let nextEvent = __spreadValues({}, event);
    function toParams(event2) {
      const params = __spreadValues({}, event2);
      delete params.name;
      return params;
    }
    const preventDefault = () => {
      isPrevented = true;
    };
    const overrideActionParams = (nextActionParams) => {
      nextEvent = __spreadValues(__spreadValues({}, nextEvent), nextActionParams);
    };
    plugins.forEach((plugin) => {
      var _a, _b, _c, _d, _e, _f;
      switch (nextEvent.name) {
        case "Pushed": {
          (_a = plugin.onBeforePush) == null ? void 0 : _a.call(plugin, {
            actionParams: __spreadValues({}, nextEvent),
            actions: __spreadProps(__spreadValues({}, actions), {
              preventDefault,
              overrideActionParams
            })
          });
          break;
        }
        case "Replaced": {
          (_b = plugin.onBeforeReplace) == null ? void 0 : _b.call(plugin, {
            actionParams: __spreadValues({}, nextEvent),
            actions: __spreadProps(__spreadValues({}, actions), {
              preventDefault,
              overrideActionParams
            })
          });
          break;
        }
        case "Popped": {
          (_c = plugin.onBeforePop) == null ? void 0 : _c.call(plugin, {
            actionParams: __spreadValues({}, nextEvent),
            actions: __spreadProps(__spreadValues({}, actions), {
              preventDefault,
              overrideActionParams
            })
          });
          break;
        }
        case "StepPushed": {
          (_d = plugin.onBeforeStepPush) == null ? void 0 : _d.call(plugin, {
            actionParams: __spreadValues({}, nextEvent),
            actions: __spreadProps(__spreadValues({}, actions), {
              preventDefault,
              overrideActionParams
            })
          });
          break;
        }
        case "StepReplaced": {
          (_e = plugin.onBeforeStepReplace) == null ? void 0 : _e.call(plugin, {
            actionParams: __spreadValues({}, nextEvent),
            actions: __spreadProps(__spreadValues({}, actions), {
              preventDefault,
              overrideActionParams
            })
          });
          break;
        }
        case "StepPopped": {
          (_f = plugin.onBeforeStepPop) == null ? void 0 : _f.call(plugin, {
            actionParams: __spreadValues({}, nextEvent),
            actions: __spreadProps(__spreadValues({}, actions), {
              preventDefault,
              overrideActionParams
            })
          });
          break;
        }
        default:
          break;
      }
    });
    return {
      isPrevented,
      overriddenParams: toParams(nextEvent)
    };
  }
  function triggerPostEffectHooks(effects, plugins) {
    effects.forEach((effect) => {
      plugins.forEach((plugin) => {
        var _a, _b, _c, _d, _e, _f, _g;
        switch (effect._TAG) {
          case "PUSHED":
            return (_a = plugin.onPushed) == null ? void 0 : _a.call(plugin, {
              actions,
              effect
            });
          case "REPLACED":
            return (_b = plugin.onReplaced) == null ? void 0 : _b.call(plugin, {
              actions,
              effect
            });
          case "POPPED":
            return (_c = plugin.onPopped) == null ? void 0 : _c.call(plugin, {
              actions,
              effect
            });
          case "STEP_PUSHED":
            return (_d = plugin.onStepPushed) == null ? void 0 : _d.call(plugin, {
              actions,
              effect
            });
          case "STEP_REPLACED":
            return (_e = plugin.onStepReplaced) == null ? void 0 : _e.call(plugin, {
              actions,
              effect
            });
          case "STEP_POPPED":
            return (_f = plugin.onStepPopped) == null ? void 0 : _f.call(plugin, {
              actions,
              effect
            });
          case "%SOMETHING_CHANGED%":
            return (_g = plugin.onChanged) == null ? void 0 : _g.call(plugin, {
              actions,
              effect
            });
          default:
            return void 0;
        }
      });
    });
  }
  const actions = {
    getStack() {
      return stack.value;
    },
    dispatchEvent,
    push(params) {
      const { isPrevented, overriddenParams } = triggerPreEffectHooks(
        makeEvent("Pushed", params),
        pluginInstances
      );
      if (isPrevented) {
        return;
      }
      dispatchEvent("Pushed", overriddenParams);
    },
    replace(params) {
      const { isPrevented, overriddenParams } = triggerPreEffectHooks(
        makeEvent("Replaced", params),
        pluginInstances
      );
      if (isPrevented) {
        return;
      }
      dispatchEvent("Replaced", overriddenParams);
    },
    pop(params) {
      const { isPrevented, overriddenParams } = triggerPreEffectHooks(
        makeEvent("Popped", params != null ? params : {}),
        pluginInstances
      );
      if (isPrevented) {
        return;
      }
      dispatchEvent("Popped", overriddenParams);
    },
    stepPush(params) {
      const { isPrevented, overriddenParams } = triggerPreEffectHooks(
        makeEvent("StepPushed", params != null ? params : {}),
        pluginInstances
      );
      if (isPrevented) {
        return;
      }
      dispatchEvent("StepPushed", overriddenParams);
    },
    stepReplace(params) {
      const { isPrevented, overriddenParams } = triggerPreEffectHooks(
        makeEvent("StepReplaced", params != null ? params : {}),
        pluginInstances
      );
      if (isPrevented) {
        return;
      }
      dispatchEvent("StepReplaced", overriddenParams);
    },
    stepPop(params) {
      const { isPrevented, overriddenParams } = triggerPreEffectHooks(
        makeEvent("StepPopped", params != null ? params : {}),
        pluginInstances
      );
      if (isPrevented) {
        return;
      }
      dispatchEvent("StepPopped", overriddenParams);
    }
  };
  return {
    actions,
    init: once(() => {
      pluginInstances.forEach((pluginInstance) => {
        var _a;
        (_a = pluginInstance.onInit) == null ? void 0 : _a.call(pluginInstance, {
          actions
        });
      });
    }),
    pullEvents: () => events.value,
    subscribe(listener) {
      storeListeners.push(listener);
      return function dispose() {
        const listenerIndex = storeListeners.findIndex((l) => l === listener);
        if (listenerIndex > -1) {
          storeListeners.splice(listenerIndex, 1);
        }
      };
    }
  };
}
export {
  aggregate,
  id,
  makeCoreStore,
  makeEvent,
  produceEffects
};
//# sourceMappingURL=index.mjs.map
